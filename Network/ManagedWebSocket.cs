using Castrimaris.Core.Monitoring;
using System;
using System.Collections.Generic;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Castrimaris.Network {

    /// <summary>
    /// A <see cref="WebSocket"/> implementation that loosely follows RFC standards and provides automatic callbacks for general events tied to the socket.
    /// </summary>
    public class ManagedWebSocket {

        #region Private Variables

        private ClientWebSocket socket;
        private Dictionary<string, string> headers;
        private string endpoint;
        private List<string> messageBuffer;
        private Task receiveTask;

        private Action onOpen;
        private Action onClose;
        private Action onError;
        private Action<string> onMessage;
        private Action<string> onPartialMessage;

        #endregion

        #region Events

        /// <summary>
        /// Event called when the WebSocket has opened.
        /// </summary>
        public event Action OnOpen { add { onOpen += value; } remove { onOpen -= value; } }

        /// <summary>
        /// Event called when the WebSocket has closed.
        /// </summary>
        public event Action OnClose { add { onClose += value; } remove { onClose -= value; } }

        /// <summary>
        /// Event called when an error is generated by the WebSocket
        /// </summary>
        public event Action OnError { add { onError += value; } remove { onError -= value; } }

        /// <summary>
        /// Event called when a message is received by the WebSocket with the flag '<see cref="WebSocketReceiveResult.EndOfMessage"/>' set to True
        /// </summary>
        public event Action<string> OnMessage { add { onMessage += value; } remove { onMessage -= value; } }

        /// <summary>
        /// Event called when a message is received by the WebSocket, even if not complete.
        /// </summary>
        public event Action<string> OnPartialMessage { add { onPartialMessage += value; } remove { onPartialMessage -= value; } }

        #endregion

        #region Properties

        /// <summary>
        /// Headers of the WebSocket. Must be defined before calling Open.
        /// </summary>
        public Dictionary<string, string> Headers => headers;

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new <see cref="ManagedWebSocket"/>.
        /// </summary>
        /// <param name="endpoint">The endpoint where to connect to. Must start with either "ws" or "wss"</param>.
        /// <param name="headers">Optional headers dictionary for additional configuration.</param>
        public ManagedWebSocket(string endpoint, Dictionary<string, string> headers) {
            messageBuffer = new List<string>();
            socket = new ClientWebSocket();

            this.headers = headers;
            this.endpoint = endpoint;
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Adds an header to the available one. Note that headers must be defined BEFORE trying to call Open!
        /// </summary>
        /// <param name="name">The name of the header (e.g. "Authentication")</param>
        /// <param name="value">The value of the header</param>
        /// <returns>True if the header was successfully added, false otherwise</returns>
        public bool AddHeader(string name, string value) {
            if (headers.ContainsKey(name))
                return false;
            headers.Add(name, value);
            return true;
        }

        /// <summary>
        /// Clears all saved headers.
        /// </summary>
        public void ClearHeaders() => headers.Clear();

        /// <summary>
        /// Opens the websocket with the data provided thus far.
        /// </summary>
        public async Task Open(CancellationToken cancellationToken = default) {


            foreach (var header in headers) {
                socket.Options.SetRequestHeader(header.Key, header.Value);
            }

            var uri = new Uri(endpoint);
            await socket.ConnectAsync(uri, cancellationToken);

            Task.Run(Receive);

            onOpen?.Invoke();
        }

        /// <summary>
        /// Sends a message through the websocket
        /// </summary>
        /// <param name="message">The message to send</param>
        public async Task Send(string message) {
            if (socket.State != WebSocketState.Open && socket.State != WebSocketState.CloseReceived) {  //Can only send data when the socket is open or the server is waiting for a close confirm
                Log.E($"Tried to send a message, but the WebSocket is not Open or CloseReceived! State: {socket.State}");
                return;
            }

            var bytes = Encoding.UTF8.GetBytes(message);
            var buffer = new ArraySegment<byte>(bytes);
            await socket.SendAsync(buffer, WebSocketMessageType.Text, true, default);
        }

        /// <summary>
        /// Closes the websockert
        /// </summary>
        /// <param name="closeStatus">Optional closing message.</param>
        public async Task Close(WebSocketCloseStatus closeStatus = WebSocketCloseStatus.NormalClosure) {
            if (socket.State == WebSocketState.Closed)
                return;

            await socket.CloseAsync(closeStatus, closeStatus.ToString(), default);
            onClose?.Invoke();
        }

        #endregion

        #region Private Methods

        private async Task Receive() {
            while (socket.State == WebSocketState.Open) {
                var buffer = new byte[1024 * 4]; //4MB buffer size. Maybe this should be configurable.
                var result = await socket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                switch (result.MessageType) {
                    case WebSocketMessageType.Close:
                        Log.W($"Received close message from server.");
                        await Close(closeStatus: WebSocketCloseStatus.EndpointUnavailable);
                        break;
                    case WebSocketMessageType.Text:
                        try {
                            var message = Encoding.UTF8.GetString(buffer);
                            //Log.D($"Received message: {message}");
                            //onPartialMessage?.Invoke(message);
                            messageBuffer.Add(message);
                            if (result.EndOfMessage) {
                                onMessage?.Invoke(string.Join("", messageBuffer));
                                messageBuffer.Clear();
                            }
                        } catch (Exception e) {
                            Log.E($"Something went wrong when receiving: {e}");
                        }
                        break;
                    case WebSocketMessageType.Binary:
                        var binaryMessage = Encoding.UTF8.GetString(buffer);
                        Log.D($"Received binary message: {binaryMessage}");
                        break;
                    default:
                        Log.E($"No such message type!");
                        break;
                }
            }
            Log.D($"Stopping receive because socket is closing...");
            await Task.CompletedTask;
        }
        #endregion
    }
}
